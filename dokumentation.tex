\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{ngerman}
\usepackage{graphicx}
\usepackage{float}

\title{Web-Programmieren}
\author{Fabian Schröder, Jan Naubert, Philip Kontny}
\date{SoSe 2021}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Einleitung}
Dies ist die Dokumentation zum Projekt im Modul 'Web-Programmieren'. Dabei wurde uns die Aufgabe gegeben einen Webmusikspieler zu erstellen. Der Musikspieler soll offline funktionieren und mit HTML, CSS, JavaScript und PHP geschrieben sein. Dabei sollen keine Drittanbieter-Bibliotheken oder ähnliches benutzt werden.

\section{Entwicklungsprozess}
Zu Beginn des Projekts haben wir uns gemeinsam zusammengesetzt und zu einem Kick-off Meeting getroffen. In diesem Meeting haben wir unsere Aufgaben und Kooperationswerkzeuge definiert. Für die Zusammenarbeit haben wir uns auf Discord für die Kommunikation und Git als Repository für den Code geeinigt. Die Aufgaben haben wir kategorisiert und in Git zu Meilensteinen zu geordnet. Dort konnten wir dann Schritt für Schritt den Entwicklungsstand unseres Musikspielers festhalten. Dies hat auch dazu geführt, dass wir immer wussten, wie viel Zeit uns bleibt und konnten so den Zeitraum für das Projekt sehr gut abschätzen. Die einzelnen Aufgaben haben wir als Issues in die Meilensteine eingefügt.\\
Zusätzlich haben wir ein Mockup erstellt, welches im späteren Verlauf dieses Dokumentes weiter ausgeführt wird. Dies sollte uns erst einmal eine grobe Richtung geben, wie wir unseren Musikspieler strukturieren möchten.

\newpage
\section{Design}
\subsection{Farbauswahl}
Unser Prozess zu der Farbauswahl hat bei dem Kick off Meeting angefangen. Wir haben uns mehrere Beispiele angeschaut, um uns zu erkundigen, welchen Wirkung Farben auf uns Menschen haben. Da einzelne Farben mit bestimmten Kategorien oder Emotionen assoziiert werden, haben wir uns zu unserem Thema überlegt, welche Branche oder auch Zielgruppe wir erreichen möchten. Dabei sind wir gemeinsam auf den Schluss gekommen, dass wir eine Moderne und verspielte Applikation erstellen wollen, welche aus der Masse hervorsticht. Dafür kamen nur wenige Farbkombinationen zur Auswahl. 
\begin{itemize}
    \item Schwarz
    \item Weiß
    \item Grau (Anthrazit)
    \item Blau
    \item Grün
    \item Orange
\end{itemize}

 \noindent Die Aufgabe die uns nun bevorstand, war eine gute Kombination zu finden, welche besonders verspielt wirkt und doch nicht an Seriosität verliert. Dabei haben wir uns entschieden die beiden Farben Orange und Gelb zu vermischen, was uns einen guten auffälligen Farbton lieferte. Da Weiß und Schwarz als Kontrast auch sehr gut mit Orange passen und die Kombination gut zu lesen ist, haben wir diese Farben für den Text oder für den Hintergrund genommen. Blau und Grün sind für die vorgegebenen Designs ausgeschieden, weil Blau einfach zu kalt wirkt und Grün, weil unsere Anwendung nicht mit Natur, Umwelt oder Gesundheit in Verbindung steht. 
 Je nach Designauswahl wollten wir diese Farben aber auch nicht explizit beschränken, sondern dem User selber auch die Entscheidung überlassen die Applikation an die eigenen Präferenzen anzupassen.
 Damit hatten wir unsere Farbpallette zusammengestellt und entworfen basierend darauf 2 Standard Designs, welche den Dark Mode mit Schwarz Abstufungen und Light Mode mit Weiße Abstufungen ausmachten.
 \begin{figure}[t]
 \centering
 \includegraphics[width=8cm,height=6cm]{img/Farben.jpg}
 \caption{Farbauswahl}
 \label{fig:farbauswahl}
\end{figure}

\newpage
\subsection{Schriftart}
Wie zuvor bei der Farbbetrachtung, haben wir hier auch, besonders unter der Beachtung der Einheitlichkeit, bei der Schriftart Wert darauf gelegt, es auf den User modern wirken zu lassen. Dafür haben wir die modernsten und meist verwendeten Webschriftarten verglichen und beschlossen somit eine Sans-serif Schrift zu nutzen, da diese als aktuell und modern zählt und in der Technologie weit verbreitet sind. Ebenfalls ermöglicht es ein angenehmes lesen auf Weboberflächen. Wir hatten am Ende die Kandidaten Roboto und Source Sans Pro. Beide Schriftarten eigneten sich gut, jedoch stach Roboto leicht hervor, da Roboto weiter verbreitet ist und sich besser für jegliche Form von Texten (Überschriften, Fließtexte, etc.) verwenden lässt.

\subsection{Branding}
Der Prozess für die Entwicklung eines Brandings haben wir wie folgt durchgeführt. Zuerst besprachen wir in der Gruppe, welche Themen und Kategorien durch den Namen vermittelt werden sollten und was für Namen in den Kontext Musik gut passen könnten. Als Beispiele sind dabei Begriffe gefallen, wie z.B. Anlage, Musikspieler, Radio, Streamingplatformen für Musik. Mithilfe dieser Begriffe Schöpften wir Neologismen, um somit eine Verbundenheit zur Musik und einen guten Wiedererkennungswert herzustellen. Am Ende sammelten wir gemeinsam unsere Überlegungen und stimmten ab. Unsere Wahl viel hierbei auf Radia, welches sehr an das Wort Radio erinnert und gleichzeitig ein wenig verspielt klingt, was auch mit der Farbauswahl gut passt.
\newpage
\subsection{Barrierefreiheit}
Die Barrierefreiheit haben wir durch verschiedene Punkte hergestellt. 
\begin{itemize}
    \item Wir haben die verwendeten Buttons größer gestaltet, sodass die Verwendung durch die Maus an einem Rechner und gleichzeitig auch für die Touchversion leichter zu treffen sind.
    \item Für Personen mit Farbblindheit oder Sehschwächen, sind Farben selbst konfigurierbar um den Kontrast zwischen unterschiedlichen Bereichen der eigenen Präferenz anzupassen.
\end{itemize}

\section{Layout}
Wie in dem Entwicklungsprozess beschrieben, haben wir beim Kick off Meeting ein Mockup entwickelt, um uns in dem Entwicklungsprozess an dieser Idee orientieren zu können. In diesem Mockup erstellten wir einfache Objektgruppen, welche die Hauptmodule unseres Designs ausmachten. Diese Module bestanden aus dem Player, der Liederliste und einer Navigationsleiste. Den Player richteten wir unten aus, damit dieser besonders auch auf Mobilgeräten nah an der Hand liegt und somit einfach zu bedienen ist. Die Liederliste wurde Zentriert angeordnet. Ebenfall für die leichtere Bedienung, da man diese Liste am zweit meisten nutzt und da sie, um möglichst viel Informationen zu liefern, den meisten Platz benötigt. Zuletzt richteten wir ganz oben die Navigationsleiste zum wechseln zwischen Funktionen aus. Mit dem Design richteten wir uns stark nach dem Minimalismus, um es Nutzern einfacher zu gestalten sich auf der Seite zurechtzufinden. Wir richteten uns nach der Regel 'as simple as possible, but not simpler'. Außerdem ließen wir in unserem Mockup viel Platz um immernoch Bereiche für potentielle weitere Funktionen zu haben (was sich später als sehr wertvoll herausstellte). Die Farben aus dem Design hatten wir erst mal uns frei Überlegt um einen ersten Eindruck zu bekommen, wie dieser Aufbau wirkt.\\

\begin{figure}[H]
 \centering
 \includegraphics[width=10cm,height=6cm]{img/mockup.png}
 \caption{Mockup}
 \label{fig:mockup}
\end{figure}

\noindent Wir sind aber bei diesem Layout nicht geblieben, da uns bei dem Entwicklungsprozess noch viele weitere Ideen kamen. Zu den neuen Ideen haben wir dann eine einfachere Skizze mit einem neuen Layout entwickelt, welche auf dem alten Layout basierte, aber deutlich mehr Funktionen zu bieten hatte. Die alten Werte des Minimalismus gingen hierbei nicht verloren.\\



\subsection{Mobile}
Für die Mobilversion haben wir uns ebenfalls eine Layoutstruktur überlegt, welche uns bei der Implementierung und Anpassung von einzelnen Elemente ein Richtung vorgab. Hierdurch konnten wir die Gestaltung der einzelnen Elemente anhand der Bildschirmgröße gut strukturieren. 
\begin{figure}[H]
 \centering
 \includegraphics[width=5cm,height=6cm]{img/mobile.png}
 \caption{Mobil aktuell}
 \label{fig:Mobil}
\end{figure}

\subsection{PC}
\begin{figure}[H]
 \centering
 \includegraphics[width=10cm,height=6cm]{img/live.png}
 \caption{Layout aktuell}
 \label{fig:layout}
\end{figure}

Wie in den Abbildungen zu sehen, sind im Gegensatz zu der Desktopversion alle Elemente in der mobilen Version übereinander gestapelt, um eine Verengung und somit eine Einschränkung der Sicht auf der Horizontalen zu vermeiden. Dies machte die Bedienung deutlich einfacher und wirkte auf uns auch deutlich moderner. Ebenfalls veränderte sich in dem Mockup auch die obere Leiste, da wir nun die Suche nach Liedern ermöglichten und in der Ecke einen gut erreichbaren Button für die Einstellungen hinzufügten.
\section{Funktionen}

\subsection{Crawler}
Wir haben uns in unserem Projekt dafür ausgesprochen dem Benutzer die Wahl zu lassen zwischen zwei Unterschiedlichen Crawlverfahren zu entscheiden. Bei unseren beiden Crawlern unterscheiden wir zwischen einem JavaScript basierten Crawler und einem Crawler, der über PHP läuft. 
Beide Crawler haben ihre Vor- und Nachteile und können jederzeit in einem Einstellungsfenster gewechselt werden.
Im Folgenden werden beide Crawlverfahren beschrieben und jeweils die Vor und Nachteile genannt.
\subsubsection{JS-Crawler}
Der JavaScript-Crawler macht von den HTML Iframes gebraucht, welche durch einen rekursiven Funktionsaufruf erstellt werden. Da durch einen Lokalen Aufruf eines Ordners auf dem Server per URL (wenn aktiviert) die Dateistruktur dieses Ordners dargestellt werden kann, ist es uns möglich, durch das Setzen der Quelle eines Iframes auf den Musikordner, Musikdateien zu durchlaufen. \newline

\noindent Zu Beginn unserer Funktion wird nach dem Erstellen unseres Iframes und dem Setzen des Musikordners durch die nun generierte Liste von Objekten in diesem Ordner iteriert. Wird ein Ordner gefunden, so wird die Funktion (rekursiv) erneut aufgerufen und ein neues Iframe wird erstellt, welches nun den gefundenen Unterordner durchsuchen kann. Mit jedem Unterordner wird auch ein neues Unterobjekt in einem JavaScript Objekt mit dem Schlüssel des Ordnernamens angehängt. Wird eine Datei mit der Endung '.mp3' oder '.ogg' gefunden, so wird diese zu dem oben genannten Objekt abhängig von dem Ordnerpfad einsortiert. Mit jeder gefundenen Musikdatei wird außerdem eine weitere Funktion aufgerufen, welche die Datei mithilfe einer GET Request downloadet und die ID3v2 Metadaten ausließt. Für die Suche von einzelnen Feldern von ID3 Metadaten (z.B. nach dem Titelfeld 'TIT2') gibt es noch eine weitere Funktion, welche durch den Anfang der Musikdatei iteriert und mithilfe eines bestimmten Musters das gefundene Datenfeld ausschneidet und zurückgibt. Da durch diese Methode jedes einzelne Lied mithilfe einer GET Request komplett gedownloadet werden muss, kann dies zu erhöhter Netzauslastung führen, sollte man das Projekt nicht lokal aufrufen (100 Lieder können hierbei schon zu einem Gigabyte Download führen). Die nun gefundenen Metadaten werden nun an den Crawler zurückgegeben und an das JavaScript Dateistrukturobjekt angehängt. Zu den gespeicherten Daten gehören Titel, Autor, Album, Typ (z.B. Elektro), Länge, Lokale URL und der Ordnerpfad.

\noindent Da wir auf das Laden der Iframes warten müssen bevor wir diese auslesen können, werden die Funktionsaufrufe mit Eventlistenern auf den Iframes ausgeführt. Damit nun auf die Crawlerfunktion Asynchron gewartet werden kann, wird zunächst nach dem Erstellen der Iframes ein Promise Objekt von der Funktion zurückgegeben, welches nach dem Finden aller Dateien gelöst wird.
Zuletzt lässt sich noch anmerken, dass der JS-Crawler bei vielen Dateien sehr lange zum Durchsuchen brauchen kann. Hierfür werden nach dem ersten Crawl die gesamte Dateistruktur in dem lokalen Speicher gesichert, damit bei erneutem Aufrufen der Seite der alte Stand schneller wieder geladen werden kann.\newline

\noindent Zusammenfassend lässt sich also sagen, dass der JavaScript-Crawler besser für die lokale Ausführung geeignet ist, da er einfacher aufzusetzen ist und nicht auf Sprachen wie PHP angewiesen ist. 

\subsubsection{PHP-Crawler}
Den PHP-Crawler haben wir als API ausgelegt, welche durch ihren Aufruf in Form einer GET Request ein JSON-Objekt mit der selben Struktur wie dem Objekt in dem JavaScript-Crawler zurückgibt. Das Ausführen benötigt mindestens die PHP-Version 7.4. Für das Durchsuchen des Musikordners haben wir hier eine PHP Funktion geschrieben, welche die PHP Methode 'scandir()' verwendet um einen gegebenen Ordner nach Dateien und weiteren Unterordnern zu durchsuchen. Alle Unterordner und Dateien werden mit derselben Struktur wie in dem JS-Crawler an ein Globales Objekt gehängt. Für jede gefundene Datei wird außerdem ein Objekt der ID3v2Parser Klasse erstellt, welches mithilfe von Regex die ID3 Felder versucht auszulesen.
Im Grunde funktioniert der PHP-Crawler also sehr ähnlich wie der JS-Crawler, nur dass er auf die Erstellung von Iframes verzichten kann und somit einfacher zu verstehen ist. Außerdem bietet er den Vorteil, dass der gesamte Crawlprozess auf dem gehosteten Computer ausgeführt wird, und somit bei einem externen Aufruf für die ID3 Tags nicht jedes einzelnes Lied heruntergeladen werden muss. Des Weiteren können Ordnerinhalte beim Aufruf ausgeblendet werden, was besonders auf öffentlichen Servern standardmäßig getan wird, um Systemsicherheit zu garantieren.\newline

\noindent Über den PHP-Crawler lässt sich also zusammenfassend sagen, dass dieser eher auf die Ausführung auf einem Server ausgelegt ist und somit auch deutlich performanter auf dem Client-Gerät läuft.

\subsection{Musiksteuerung}
Die Steuerung haben wir selbst implementiert. Dabei haben wir die Funktionen mit JavaScript umgesetzt. Die Grundlage dabei ist ein Audio Objekt aus der grundlegenden JavaScript Bibliothek. Information und Daten über das aktuelle Lied speichern wir im Webstorage. Wir haben folgende Steuerungsfunktionen erstellt:
\begin{itemize}
    \item Start/Pause
    \item Skip (nach vorne)
    \item Back (nach hinten)
    \item Loop (Wiederholung)
    \item Shuffle (Mischen)
    \item Lautstärkesteuerung
\end{itemize}
Bei Start/Pause handelt es sich um einen Knopf, der wie ein Schalter funktioniert. Dabei zeigt er immer an, was passieren wird, wenn man ihn betätigt, sprich wenn die Musik spielt sieht man das Pausesymbol und dementsprechend auch umgekehrt. Der Knopf aktualisiert sich auch, wenn der Spieler durch andere Quellen, wie zum Beispiel das Ändern des Liedes, beeinflusst wird. Wir als Team haben uns bewusst gegen einen Stopknopf entschieden, da dieser in digitalen Medien aus unserer Sicht keinen Verwendungszweck hat. Der Stopknopf kommt von den analogen Musikspielern und hat zum Beispiel die CD dazu gebracht aufzuhören zu rotieren, damit man die CD beim Öffnen des CD-Spielers nicht beschädigt wird. In den Anfängen der digitalen Medien wurde der Stopknopf häufig benutzt, um an das Ende des Liedes zu springen und die Wiedergabe zu beenden. Wenn man sich große Musikplattformen anguckt wird man den Stopknopf auch nicht mehr finden und keiner von uns im Team würde ihn benutzen.\\

\noindent Die Funktion Skip lässt den Spieler das nächste Lied aus der erstellten Liste spielen. Dabei werden sowohl die Liedinformationen, als auch das Anzeigen des Fortschrittes des Liedes auf der Seite angepasst.\\

\noindent Back macht ca. das Gleiche wie Skip. Der Unterschied ist, dass es nicht nach vorne sondern nach hinten geht. Des Weiteren gibt es bei der Backfunktion noch die Besonderheit, dass wenn das Lied mehr als drei Sekunden gespielt ist, dass es nicht ein Lied zurück geht, sondern zum Anfang des Liedes springt. Wenn das Lied weniger als drei Sekunden läuft wird zum Lied davor gesprungen.\\

\noindent Bei unserer Loop(Wiederholung)-Implementierung haben wir uns dafür entschieden, dass es immer das Lied wiederholt, welches gerade spielt. Das heißt, wenn das Lied beendet wurde fängt es wieder von vorne an. Wenn man ein Lied weiter möchte kann man entweder die Skip-Funktion benutzen oder den Loop wieder ausschalten.\\

\noindent Die Shuffle Funktion verändert die Reihenfolge der aktuellen Liste. Hierbei wird das Lied, welches in dem Moment gespielt wird, an erste Position gesetzt und die restlichen Lieder, auch die die schon gespielt wurden. Dabei benutzen wir als erstes den den Fisher-Yates-Shuffle. Es werden die Stellen der Liste einmal durchlaufen und das Element an dieser Stelle mit einem Element an einer zufälligen Stelle der Liste getauscht. Im zweiten Schritt wird die Liste noch einmal durchlaufen und es wird nach dem aktuellen Lied gesucht und dieses wird dann mit dem Lied an der ersten Stelle getauscht. Wir haben jedes Lied mit einem Index versehen, somit können wir die ursprüngliche Reihenfolge der Lieder wieder herstellen und die Funktion umkehren.\\

\noindent Für die Lautstärkeregelung haben wir einen Regler implementiert mit dem man die Lautstärke dynamisch steuern kann. Dabei passt sich die Lautstärke in Echtzeit an. Des Weiteren kann man auch den Musikspieler stumm schalten. Dafür gibt es einen Knopf neben dem Slider. Auf den mobilen Endgeräten lässt sich die Lautstärke nicht regeln, außer das Stummschalten. Wir haben uns trotzdem entschlossen den Regler weiter anzeigen zu lassen, da man den Musikspieler auch gut als kleines Fenster an der Seite auf dem Desktop-PC benutzen kann und somit sonst nicht alle Features der Anwendung benutzbar wären.
\subsection{Songlist}
Für die allgemeine Handhabung von Songlisten haben wir eine Klasse erstellt, da wir diese an mehreren Stellen in dem Projekt benutzen. Die Lieder in der Listen beinhalten Lieder und deren Information (wie Metadaten, Position, etc.). Dadurch können wir eine Liste für die aktuellen abgespielten Lieder und die Lieder die gerade gesucht werden oder in einer Playlist sind separat ansprechen und dennoch haben beide die gleiche Struktur. Wir haben die Klasse so implementiert, dass man Konfigurationen einstellen kann, wie zum Beispiel, dass man Lieder aus der Liste auswählen kann oder ob man die Liste sortieren darf. Des Weiteren kann man sich die Informationen der Liste übergeben lassen, dabei kann man die Liste auch nach den Eigenschaften der Lieder filter oder oder sortieren. Es ist möglich mehrere Lieder gleichzeitig auszuwählen und zu einer Playlist hinzufügen. Des Weiteren ist es möglich Lieder nach dem gespielten Lied in die Warteschlange einzufügen
\subsection{Playlist}
Playlisten beinhalten manuell hinzugefügte Lieder und deren Informationen. Man kann sowohl ein Lied oder auch mehrere Lieder auf einmal zu einer Playlist hinzufügen. Dazu ist es möglich den Playlistnamen jederzeit zu ändern. Die Playlisten werden im Webstorage gespeichert, sodass sie weitestgehend konsistent sind. Man kann so viele Playlisten anlegen wie man möchte. Gleiche Namensgebung spielt dabei keine Rolle,
\subsection{Visualizer}
Den Visualizer findet man auf unserer Seite wenn man den Muskispieler ausklappt und und somit auf die Warteschlange gelangt. Es ist ein typischer Visualizer, der aus Balken besteht, welche je nach Frequenzen und Amplituden auf die Musik reagieren. Dabei liegen die Balken die die tiefen Töne darstellen auf der linken Seite und die höheren auf der rechten.\newline

\noindent Die Umsetzung geschieht mit Hilfe eines Canvas und einen Analyzers von einem AudioContext Objektes. Mit Hilfe von dem Analyzer lesen wir die aktuellen Frequenzwerte aus und berechnen die Höhe der der einzelnen Balken und zeichnen dann dementsprechend Rechtecke mit der Kontrastfarbe unserer Seite in das Canvas.
\subsection{Einstellungen}
Wir haben verschiedenen Einstellung bei unserer Anwendung entwickelt. Die Einstellungen werden auch im Webstorage gespeichert, sodass man nicht jedes Mal diese wieder einrichten muss.
\begin{itemize}
    \item Themeauswahl
    \item Auswahl des Crawlers
    \item Löschen der gespeicherten Daten
    \item Ein-/Ausschalten des Logs
    \item Extras
\end{itemize}
Als Themes haben wir neben dem Darkmode (Standard) und dem Lightmode noch eine Besonderheit. Auf unserer Seite kann benutzen wir 5 Variablen, die die Farben bestimmen. Es gibt 3 Hintergrundfarben dazu eine Textfarbe und eine Kontrastfarbe. All diese können mit Hilfe einer integrierten Farbauswahl angepasst werden. Somit kann man unsere Seite in einem Stil nach seinem Geschmack neu aufleben lassen.\newline
Des Weiteren kann zwischen unseren beiden implementierten Crawler auswählen. Einmal haben wir den Serverseitigen PHP Crawler und als zweite Auswahl kann man noch den JavaScript Crawler benutzen.\newline
Dazu ermöglichen unsere Einstellunge, dass man die gespeicherten Daten, wie Playlist und und Themes, sprich alle Daten die im Webstorage liegen werden einmal gelöscht. Die Auswirkungen kann man erst nach einem Neuladen der Seite feststellen.\newline
Eine weitere Einstellungsmöglichkeit ist das Ein-/Ausstellen von den Logs der Aktivitäten des Musikspielers. Hierbei werden Aktionen, wie 'audio started' oder oder 'song list shuffled' in der Entwicklerkonsole ausgegeben.\newline
Die letzten Einstellungen sind zum einen das Aktivieren der Ladeanimation beim betreten der Seite und zum anderen das Auswählen der Sprache. Wobei letzteres nur angedeutet ist und wir leider nicht mehr zeitlich ins Projekt mit einbringen konnten.
\section{Fazit}
Die Projektarbeit ist sehr erfolgreich verlaufen. Wir konnten als Team trotz Verlust einer Person direkt zu Anfang zu dritt die Aufgaben gut bearbeiten und sind am Ende mit unserer gemeinsamen Planung sehr gut durchgekommen, da wir sie gut durchdacht haben, angefangen beim Kick-Off Meeting bis hin zum Projektstart. Durch diese Planung sind wir auch Zeitlich immer im Rahmen des Zeitraums geblieben und sind somit nicht in Zeitmangel geraten. Wir kamen so gut mit dem Projekt voran, da wir uns alle sehr für das Thema interessiert haben und wir teilweise schon kleinere Vorkenntnisse in Teilgebieten der Aufgabe hatten. Das einzige was wir ein bisschen strukturierter hätten durchziehen können, ist das kontinuierliche Kommentieren und führen unserer Kommentare und Dokumentationen. Ebenfalls unterstützend war die gute Kommunikation zwischen den Teammitgliedern, da wir alle durchgehend in Kontakt standen über Discord.

\end{document}
