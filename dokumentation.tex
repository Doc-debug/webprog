\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{ngerman}
\usepackage{graphicx}
\usepackage{float}

\title{Web-Programmieren}
\author{Fabian Schröder, Jan Naubert, Philip Kontny}
\date{SoSe 2021}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Einleitung}
Dies ist die Dokumentation zum Projekt im Modul 'Web-Programmieren'. Dabei wurde uns die Aufgabe gegeben einen Webmusikspieler zu erstellen. Der Musikspieler soll offline funktionieren und mit HTML, CSS, JavaScript und PHP geschrieben sein. Dabei sollen keine Drittanbieter-Bibliotheken oder ähnliches benutzt werden.

\section{Entwicklungsprozess}
Zu Beginn des Projekts haben wir uns gemeinsam zusammengesetzt und zu eine Kick-off Meeting getroffen. In diesem Meeting haben wir unsere Aufgaben, Kooperationswerkzeuge definiert. Als Kooperationswerkzeug haben wir uns auf Discord für die Kommunikation und Git als repository für den Code geeinigt. Die Aufgaben haben wir kategorisiert und in Git zu Meilensteinen zu geordnet. Dort konnten wir dann Schritt für Schritt den Entwicklungsstand unseres Musikspielers festhalten. Dies hat auch dazu geführt, dass wir immer wussten, wie viel Zeit uns bleibt und konnten so den Zeitraum für das Projekt sehr gut abschätzen. Die einzelnen Aufgaben haben wir als Issues in die Meilensteine gepackt.\\
Zusätzlich haben wir ein Mockup erstellt, welches im späteren Verlauf erklärt wird. Dies sollte uns erst einmal eine grobe Richtung geben, wie wir unseren Musikspieler strukturieren möchten.

\newpage
\section{Design}
\subsection{Farbauswahl}
Unser Prozess zu der Farbauswahl hat bei dem Kick off Meeting angefangen. Wir haben uns mehrere Beispiele angeschaut, um uns zu erkundigen, welchen Wirkung Farben auf uns Menschen haben. Da einzelne Farben mit bestimmte Kategorien oder Emotionen assoziiert werden, haben wir uns zu unserem Thema überlegt, welche Branche oder auch Zielgruppe wir erreichen möchten. Dabei sind wir gemeinsam auf den Schluss gekommen, wir möchten es Modern und verspielt wirken lassen und auch aus der Masse hervorstechen. Dafür kamen nur wenige Farbkombinationen zur Auswahl. 
\begin{itemize}
    \item Schwarz
    \item Weiß
    \item Grau (Anthrazit)
    \item Blau
    \item Grün
    \item Orange
\end{itemize}

 \noindent Das Problem bei der Auswahl war, wie wollen wir den Musikspieler verspielt wirken lassen. Dabei haben wir uns entschieden beide Farben Orange und Gelb zu vermischen, um so das verspielte gut darstellen konnten und wir somit unseren Kontrast gefunden hatten. Da Weiß und Schwarz als Kontrast auch sehr gut mit Orange passen und es gut zu lesen ist, haben wir diese Farben für den Text oder für den Hintergrund genommen. Blau und Grün sind für die vorgegebenen Designs ausgeschieden, weil Blau einfach zu kalt wirkt und Grün weil wir keine Anwendung geschrieben haben, die mit Natur, Umwelt oder Gesundheit in Verbindung gebracht werden soll. 
 Je nach Designauswahl wollen wir diese Farben aber auch nicht explizit beschränken, sondern der User sollte selber entscheiden können was ihm gefällt, wenn man die Anwendung z.B. als tägliche Anwendung verwenden möchte.
 Damit hatten wir unsere Farbpallette zusammengestellt und haben daraufhin 2 Standard Designs entworfen einmal den Dark Mode mit Schwarz Abstufungen und Light Mode mit Weiße Abstufungen.
 \begin{figure}[t]
 \centering
 \includegraphics[width=8cm,height=6cm]{img/Farben.jpg}
 \caption{Farbauswahl}
 \label{fig:farbauswahl}
\end{figure}

\newpage
\subsection{Schriftart}
Wie zuvor bei der Farbbetrachtung, haben wir hier unter der beachtung, dass wir einheitlich bleiben auch uns bei der Schriftart überlegt es modern wirken zu lassen auf den User. Dafür haben wir uns die modernsten oder meist verwendeten Schriftarten angeschaut und sind für uns zu einer Sans-serif Schrift gekommen, da diese als aktuell, modern zählt und in der Technologie viel verwendet werden. Ebenfalls ermöglicht es ein angenehmes lesen. Wir hatten am ende zwei mögliche Kandidaten Roboto und Source Sans Pro. Beide Schriftarten eigneten sich gut, doch unsere Wahl war Roboto. Roboto ist zu der aktuellen Zeit bei der Erstellung der Planung häufiger genutzt und somit konnten wir uns entscheiden.

\subsection{Branding}
Der Prozess für die Entwicklung eines Brandings haben wir so durchgeführt. Erst mal haben wir Themen gemeinsam besprochen was wir für Kategorien über den Namen vermitteln möchten und was sich nach Musik anhört. Als Beispiele sind da Begriffe gefallen, wie z.B. Anlage, Musikspieler, Radio, Streamingplatformen für Musik. Anhand dieser Kategorien hat sich jeder Begriffe einfallen lassen und hat diese notiert. Am Ende haben wir alle gemeinsam unsere Überlegungen gesammelt und abgestimmt. Unsere Wahl viel hierbei auf Radia, welches sehr nach Radio aber auch leicht verspielt klingt, was sich auch bei der Farbauswahl wiederspiegelt.
\newpage
\subsection{Barrierefreiheit}
Die Barrierefreiheit haben wir durch verschiedene Punkte hergestellt. 
\begin{itemize}
    \item Wir haben die verwendeten Buttons größer gestaltet, sodass die Verwendung durch die Maus an einem Rechner und gleichzeitig auch für die Touchversion leichter zu treffen sind.
    \item Für Personen mit Farbblindheit oder auch direkte Schwächen beim sehen, können sich die Farben selber anpassen und durch das Highlighten von angewählten Elementen können die Kontraste besser wahrgenommen werden, da jeder Benutzer sich die Farben auf ihre eigenen Bedürfnisse konfigurieren können.
\end{itemize}

\section{Layout}
Wie in dem Entwicklungsprozess beschrieben, haben wir beim Kick off Meeting ein Mockup entwickelt, da wir unsere Anwendung im Design es somit durchdachter und einfacher anhand des Mockups entwickeln konnten. Bei dem Layout wollten wir eine Gruppierung der Elemente haben, sodass wir Steuerelemente für den Musikspieler unten haben für das leichtere Erreichen was auch bei der Touchversion hilfreich ist. Die Liederliste centered, ebenfall für die leichtere Bedienung, da man diese Listen am zweit meisten verwendet und ganz oben ein Block mit Elementen, zum wechseln zwischen Funktionen. Das Design haben wir erst grob modern Entwickelt. Das Design ist aber für uns auch eine Grundstruktur gewesen. Wir wollen auch bei dem Layout erreichen 'as simple as possible, but not simpler' damit wollten wir uns auf wirklich das nötigste Beschränken, wie man auch an der Mockup Abbildung sieht, ist alles sehr reduziert. Die Farben aus dem Design hatten wir erst mal uns frei Überlegt um einen ersten Eindruck zu bekommen, wie dieser Aufbau wirkt.\\

\begin{figure}[H]
 \centering
 \includegraphics[width=10cm,height=6cm]{img/mockup.png}
 \caption{Mockup}
 \label{fig:mockup}
\end{figure}

\noindent Wir sind aber bei diesem Layout nicht geblieben, da uns bei dem Entwicklungsprozess noch schönere Ideen kamen. Zu den neuen Ideen haben wir eine Skizze zu dem neuen Layout entwickelt wir haben das Layout so angepasst, dass wir die Elemente etwas anders Strukturieren können und so auch die Verwendung erleichtern konnten.\\



\subsection{Mobile}
Für die Mobileversion haben wir uns ebenfalls eine Layoutstruktur überlegt, die uns bei der Implementierung für das Anpassen der einzelnen Elemente ein Richtung vorgibt. Hiermit können wir die Gestaltung der einzelnen Elemente durch die Bildschirmgröße anpassen. 
\begin{figure}[H]
 \centering
 \includegraphics[width=5cm,height=6cm]{img/mobile.png}
 \caption{Mobil aktuell}
 \label{fig:Mobil}
\end{figure}

\subsection{PC}
\begin{figure}[H]
 \centering
 \includegraphics[width=10cm,height=6cm]{img/live.png}
 \caption{Layout aktuell}
 \label{fig:layout}
\end{figure}

Wie hier in der Abbildung zu sehen ist sie die Elemente von der Oben an die Seiten verschoben, da wir es einfacher in der Bedienung empfanden und es nach Recherchen auch moderne ist. Ebenfalls hat sich zu dem Mockup auch die obere Leiste verändert, da dort nun die Suche nach Liedern ermöglicht wird und wir haben oben links in der Ecke die Einstellungen hinzugefügt, um es übersichtlicher zu halten und es nicht zu überladen.
\section{Funktionen}

\subsection{Crawler}
Wir haben uns in unserem Projekt dafür ausgesprochen dem Benutzer die Wahl zu lassen zwischen zwei Unterschiedlichen Crawlverfahren zu entscheiden. Bei unseren beiden Crawlern unterscheiden wir zwischen einem JavaScript basierten Crawler und einem Crawler, der über PHP läuft. 
Beide Crawler haben ihre Vor- und Nachteile und können jederzeit in einem Einstellungsfenster gewechselt werden.
Im Folgenden werden beide Crawlverfahren beschrieben und jeweils die Vor und Nachteile genannt.
\subsubsection{JS-Crawler}
Der JavaScript-Crawler macht von den HTML Iframes gebraucht, welche durch einen rekursiven Funktionsaufruf erstellt werden. Da durch einen Lokalen Aufruf eines Ordners auf dem Server per URL (wenn aktiviert) die Dateistruktur dieses Ordners dargestellt werden kann, ist es uns möglich, durch das Setzen der Quelle eines Iframes auf den Musikordner, Musikdateien zu durchlaufen. \newline

\noindent Zu Beginn unserer Funktion wird nach dem Erstellen unseres Iframes und dem Setzen des Musikordners durch die nun generierte Liste von Objekten in diesem Ordner iteriert. Wird ein Ordner gefunden, so wird die Funktion (rekursiv) erneut aufgerufen und ein neues Iframe wird erstellt, welches nun den gefundenen Unterordner durchsuchen kann. Mit jedem Unterordner wird auch ein neues Unterobjekt in einem JavaScript Objekt mit dem Schlüssel des Ordnernamens angehängt. Wird eine Datei mit der Endung '.mp3' oder '.ogg' gefunden, so wird diese zu dem oben genannten Objekt abhängig von dem Ordnerpfad einsortiert. Mit jeder gefundenen Musikdatei wird außerdem eine weitere Funktion aufgerufen, welche die Datei mithilfe einer GET Request downloadet und die ID3v2 Metadaten ausließt. Für die Suche von einzelnen Feldern von ID3 Metadaten (z.B. nach dem Titelfeld 'TIT2') gibt es noch eine weitere Funktion, welche durch den Anfang der Musikdatei iteriert und mithilfe eines bestimmten Musters das gefundene Datenfeld ausschneidet und zurückgibt. Da durch diese Methode jedes einzelne Lied mithilfe einer GET Request komplett gedownloadet werden muss, kann dies zu erhöhter Netzauslastung führen, sollte man das Projekt nicht lokal aufrufen (100 Lieder können hierbei schon zu einem Gigabyte Download führen). Die nun gefundenen Metadaten werden nun an den Crawler zurückgegeben und an das JavaScript Dateistrukturobjekt angehängt. Zu den gespeicherten Daten gehören Titel, Autor, Album, Typ (z.B. Elektro), Länge, Lokale URL und der Ordnerpfad.

\noindent Da wir auf das Laden der Iframes warten müssen bevor wir diese auslesen können, werden die Funktionsaufrufe mit Eventlistenern auf den Iframes ausgeführt. Damit nun auf die Crawlerfunktion Asynchron gewartet werden kann, wird zunächst nach dem Erstellen der Iframes ein Promise Objekt von der Funktion zurückgegeben, welches nach dem Finden aller Dateien gelöst wird.
Zuletzt lässt sich noch anmerken, dass der JS-Crawler bei vielen Dateien sehr lange zum Durchsuchen brauchen kann. Hierfür werden nach dem ersten Crawl die gesamte Dateistruktur in dem lokalen Speicher gesichert, damit bei erneutem Aufrufen der Seite der alte Stand schneller wieder geladen werden kann.\newline

\noindent Zusammenfassend lässt sich also sagen, dass der JavaScript-Crawler besser für die lokale Ausführung geeignet ist, da er einfacher aufzusetzen ist und nicht auf Sprachen wie PHP angewiesen ist. 

\subsubsection{PHP-Crawler}
Den PHP-Crawler haben wir als API ausgelegt, welche durch ihren Aufruf in Form einer GET Request ein JSON-Objekt mit der selben Struktur wie dem Objekt in dem JavaScript-Crawler zurückgibt. Das Ausführen benötigt mindestens die PHP-Version 7.4. Für das Durchsuchen des Musikordners haben wir hier eine PHP Funktion geschrieben, welche die PHP Methode 'scandir()' verwendet um einen gegebenen Ordner nach Dateien und weiteren Unterordnern zu durchsuchen. Alle Unterordner und Dateien werden mit derselben Struktur wie in dem JS-Crawler an ein Globales Objekt gehängt. Für jede gefundene Datei wird außerdem ein Objekt der ID3v2Parser Klasse erstellt, welches mithilfe von Regex die ID3 Felder versucht auszulesen.
Im Grunde funktioniert der PHP-Crawler also sehr ähnlich wie der JS-Crawler, nur dass er auf die Erstellung von Iframes verzichten kann und somit einfacher zu verstehen ist. Außerdem bietet er den Vorteil, dass der gesamte Crawlprozess auf dem gehosteten Computer ausgeführt wird, und somit bei einem externen Aufruf für die ID3 Tags nicht jedes einzelnes Lied heruntergeladen werden muss. Des Weiteren können Ordnerinhalte beim Aufruf ausgeblendet werden, was besonders auf öffentlichen Servern standardmäßig getan wird, um Systemsicherheit zu garantieren.\newline

\noindent Über den PHP-Crawler lässt sich also zusammenfassend sagen, dass dieser eher auf die Ausführung auf einem Server ausgelegt ist und somit auch deutlich performanter auf dem Client-Gerät läuft.

\subsection{Musiksteuerung}
Die Steuerung haben wir selbst implementiert. Dabei haben wir die Funktionen mit JavaScript umgesetzt. Die Grundlage dabei ist ein Audio Objekt aus der grundlegenden JavaScript Bibliothek. Information und Daten über das aktuelle Lied speichern wir im Webstorage. Wir haben folgende Steuerungsfunktionen erstellt:
\begin{itemize}
    \item Start/Pause
    \item Skip (nach vorne)
    \item Back (nach hinten)
    \item Loop (Wiederholung)
    \item Shuffle (Mischen)
    \item Lautstärkesteuerung
\end{itemize}
Bei Start/Pause handelt es sich um einen Knopf, der wie ein Schalter funktioniert. Dabei zeigt er immer an, was passieren wird, wenn man ihn betätigt, sprich wenn die Musik spielt sieht man das Pausesymbol und dementsprechend auch umgekehrt. Der Knopf aktualisiert sich auch, wenn der Spieler durch andere Quellen, wie zum Beispiel das Ändern des Liedes, beeinflusst wird. Wir als Team haben uns bewusst gegen einen Stopknopf entschieden, da dieser in digitalen Medien aus unserer Sicht keinen Verwendungszweck hat. Der Stopknopf kommt von den analogen Musikspielern und hat zum Beispiel die CD dazu gebracht aufzuhören zu rotieren, damit man die CD beim Öffnen des CD-Spielers nicht beschädigt wird. In den Anfängen der digitalen Medien wurde der Stopknopf häufig benutzt, um an das Ende des Liedes zu springen und die Wiedergabe zu beenden. Wenn man sich große Musikplattformen anguckt wird man den Stopknopf auch nicht mehr finden und keiner von uns im Team würde ihn benutzen.\\

\noindent Die Funktion Skip lässt den Spieler das nächste Lied aus der erstellten Liste spielen. Dabei werden sowohl die Liedinformationen, als auch das Anzeigen des Fortschrittes des Liedes auf der Seite angepasst.\\

\noindent Back macht ca. das Gleiche wie Skip. Der Unterschied ist, dass es nicht nach vorne sondern nach hinten geht. Des Weiteren gibt es bei der Backfunktion noch die Besonderheit, dass wenn das Lied mehr als drei Sekunden gespielt ist, dass es nicht ein Lied zurück geht, sondern zum Anfang des Liedes springt. Wenn das Lied weniger als drei Sekunden läuft wird zum Lied davor gesprungen.\\

\noindent Bei unserer Loop(Wiederholung)-Implementierung haben wir uns dafür entschieden, dass es immer das Lied wiederholt, welches gerade spielt. Das heißt, wenn das Lied beendet wurde fängt es wieder von vorne an. Wenn man ein Lied weiter möchte kann man entweder die Skip-Funktion benutzen oder den Loop wieder ausschalten.\\

\noindent Die Shuffle Funktion verändert die Reihenfolge der aktuellen Liste. Hierbei wird das Lied, welches in dem Moment gespielt wird, an erste Position gesetzt und die restlichen Lieder, auch die die schon gespielt wurden. Dabei benutzen wir als erstes den den Fisher-Yates-Shuffle. Es werden die Stellen der Liste einmal durchlaufen und das Element an dieser Stelle mit einem Element an einer zufälligen Stelle der Liste getauscht. Im zweiten Schritt wird die Liste noch einmal durchlaufen und es wird nach dem aktuellen Lied gesucht und dieses wird dann mit dem Lied an der ersten Stelle getauscht. Wir haben jedes Lied mit einem Index versehen, somit können wir die ursprüngliche Reihenfolge der Lieder wieder herstellen und die Funktion umkehren.\\

\noindent Für die Lautstärkeregelung haben wir einen Regler implementiert mit dem man die Lautstärke dynamisch steuern kann. Dabei passt sich die Lautstärke in Echtzeit an. Des Weiteren kann man auch den Musikspieler stumm schalten. Dafür gibt es einen Knopf neben dem Slider. Auf den mobilen Endgeräten lässt sich die Lautstärke nicht regeln, außer das Stummschalten. Wir haben uns trotzdem entschlossen den Regler weiter anzeigen zu lassen, da man den Musikspieler auch gut als kleines Fenster an der Seite auf dem Desktop-PC benutzen kann und somit sonst nicht alle Features der Anwendung benutzbar wären.
\subsection{Songlist}
Für die allgemeine Handhabung von Songlisten haben wir eine Klasse erstellt, da wir diese an mehreren Stellen in dem Projekt benutzen. Die Lieder in der Listen beinhalten Lieder und deren Information (wie Metadaten, Position, etc.). Dadurch können wir eine Liste für die aktuellen abgespielten Lieder und die Lieder die gerade gesucht werden oder in einer Playlist sind separat ansprechen und dennoch haben beide die gleiche Struktur. Wir haben die Klasse so implementiert, dass man Konfigurationen einstellen kann, wie zum Beispiel, dass man Lieder aus der Liste auswählen kann oder ob man die Liste sortieren darf. Des Weiteren kann man sich die Informationen der Liste übergeben lassen, dabei kann man die Liste auch nach den Eigenschaften der Lieder filter oder oder sortieren. Es ist möglich mehrere Lieder gleichzeitig auszuwählen und zu einer Playlist hinzufügen. Des Weiteren ist es möglich Lieder nach dem gespielten Lied in die Warteschlange einzufügen
\subsection{Playlist}
Playlisten beinhalten manuell hinzugefügte Lieder und deren Informationen. Man kann sowohl ein Lied oder auch mehrere Lieder auf einmal zu einer Playlist hinzufügen. Dazu ist es möglich den Playlistnamen jederzeit zu ändern. Die Playlisten werden im Webstorage gespeichert, sodass sie weitestgehend konsistent sind. Man kann so viele Playlisten anlegen wie man möchte. Gleiche Namensgebung spielt dabei keine Rolle,
\subsection{Visualizer}
Den Visualizer findet man auf unserer Seite wenn man den Muskispieler ausklappt und und somit auf die Warteschlange gelangt. Es ist ein typischer Visualizer, der aus Balken besteht, welche je nach Frequenzen und Amplituden auf die Musik reagieren. Dabei liegen die Balken die die tiefen Töne darstellen auf der linken Seite und die höheren auf der rechten.\newline

\noindent Die Umsetzung geschieht mit Hilfe eines Canvas und einen Analyzers von einem AudioContext Objektes. Mit Hilfe von dem Analyzer lesen wir die aktuellen Frequenzwerte aus und berechnen die Höhe der der einzelnen Balken und zeichnen dann dementsprechend Rechtecke mit der Kontrastfarbe unserer Seite in das Canvas.
\subsection{Einstellungen}
Wir haben verschiedenen Einstellung bei unserer Anwendung entwickelt. Die Einstellungen werden auch im Webstorage gespeichert, sodass man nicht jedes Mal diese wieder einrichten muss.
\begin{itemize}
    \item Themeauswahl
    \item Auswahl des Crawlers
    \item Löschen der gespeicherten Daten
    \item Ein-/Ausschalten des Logs
    \item Extras
\end{itemize}
Als Themes haben wir neben dem Darkmode (Standard) und dem Lightmode noch eine Besonderheit. Auf unserer Seite kann benutzen wir 5 Variablen, die die Farben bestimmen. Es gibt 3 Hintergrundfarben dazu eine Textfarbe und eine Kontrastfarbe. All diese können mit Hilfe einer integrierten Farbauswahl angepasst werden. Somit kann man unsere Seite in einem Stil nach seinem Geschmack neu aufleben lassen.\newline
Des Weiteren kann zwischen unseren beiden implementierten Crawler auswählen. Einmal haben wir den Serverseitigen PHP Crawler und als zweite Auswahl kann man noch den JavaScript Crawler benutzen.\newline
Dazu ermöglichen unsere Einstellunge, dass man die gespeicherten Daten, wie Playlist und und Themes, sprich alle Daten die im Webstorage liegen werden einmal gelöscht. Die Auswirkungen kann man erst nach einem Neuladen der Seite feststellen.\newline
Eine weitere Einstellungsmöglichkeit ist das Ein-/Ausstellen von den Logs der Aktivitäten des Musikspielers. Hierbei werden Aktionen, wie 'audio started' oder oder 'song list shuffled' in der Entwicklerkonsole ausgegeben.\newline
Die letzten Einstellungen sind zum einen das Aktivieren der Ladeanimation beim betreten der Seite und zum anderen das Auswählen der Sprache. Wobei letzteres nur angedeutet ist und wir leider nicht mehr zeitlich ins Projekt mit einbringen konnten.
\section{Fazit}
Die Projektarbeit ist sehr erfolgreich verlaufen. Wir konnten als Team trotz Verlust einer Person direkt zu Anfang zu dritt die Aufgaben gut bearbeiten und sind am Ende mit unserer gemeinsamen Planung sehr gut durchgekommen, da wir sie gut durchdacht haben, angefangen beim Kick-Off Meeting bis hin zum Projektstart. Durch diese Planung sind wir auch Zeitlich immer im Rahmen des Zeitraums geblieben und sind somit nicht in Zeitmangel geraten. Wir kamen so gut mit dem Projekt voran, da wir uns alle sehr für das Thema interessiert haben und wir teilweise schon kleinere Vorkenntnisse in Teilgebieten der Aufgabe hatten. Das einzige was wir ein bisschen strukturierter hätten durchziehen können, ist das kontinuierliche Kommentieren und führen unserer Kommentare und Dokumentationen. Ebenfalls unterstützend war die gute Kommunikation zwischen den Teammitgliedern, da wir alle durchgehend in Kontakt standen über Discord.

\end{document}
